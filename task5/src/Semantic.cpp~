#include "Semantic.hpp"
#include <unordered_map>
#include <fstream>

void Semantic::analysis() const {
	std::ofstream out;
	out.open("tree_expression.cpp");
	out << "#include \"task5.hpp\"" << std::endl;
	out << "extern \"C\" void print(Customer *customer){" << std::endl;

	int scanNumber = 0;
			
	std::unordered_map<std::string, std::string> operation;

	for(std::string relationname: query.relations){
		bool flag = false;
		for(Schema::Relation& relation : schema->relations){
			if(relationname == relation.name){
				flag = true;
				out << "TableScan* tableScan" + std::to_string(scanNumber) + " = new TableScan(" + relationname + ");" << std::endl;
				operation[relationname] = "tableScan" + std::to_string(scanNumber);
				bool selectname = false;				
				for(std::pair<std::string, std::string> select : query.selectconditions){
					for(Schema::Relation::Attribute attribute : relation.attributes){	
						if(attribute.name == select.first){
							if(!selectname){
								out << "Selection* selection"+std::to_string(scanNumber) + " = new Selection(tableScan"+std::to_string(scanNumber) + ");" << std::endl;
								operation[relationname] = "selection" + std::to_string(scanNumber);
								selectname = true;
							}
							if(attribute.type == Types::Tag::Char || attribute.type == Types::Tag::Varchar)
								out << "selection" + std::to_string(scanNumber) + "->condition.push_back(std::make_pair(\""+select.first+"\", " + "\"\\\""+select.second + "\\\"\"));" << std::endl;							
							else
								out << "selection" + std::to_string(scanNumber) + "->condition.push_back(std::make_pair(\""+select.first+"\", " + "\""+select.second + "\"));" << std::endl;							
						}
					}
							//if(!selectname){
							//		throw SemanticError("Attribute " + select.first + " doesn't exist in any table");
							//}
				}
			}
		}
			
		if(!flag){
			out << relationname + " relation doesn't exist" << std::endl;
		}else{
			scanNumber++;
		}
	}

	int joinNumber = 0;
	if(query.relations.size() > 1){
		for(unsigned i = 0; i < query.relations.size() - 1; i++){
			for(Schema::Relation& relation : schema->relations){
				if(query.relations[i] == relation.name){
					for(Schema::Relation& relationA : schema->relations){
						if(query.relations[i+1] == relationA.name){
							bool joinname = false;

							for(std::pair<std::string, std::string> join : query.joinconditions){
								bool leftjoinname = false;
								bool rightjoinname = false;
								for(Schema::Relation::Attribute attribute : relation.attributes){	
									if(attribute.name == join.first){
										leftjoinname = true;
										for(Schema::Relation::Attribute attributeA : relationA.attributes){	
											if(attributeA.name == join.second){
												rightjoinname = true;
												if(!joinname){
													out << "HashJoin* hashJoin"+std::to_string(joinNumber) + " = new HashJoin("+ operation[relation.name] +", " + operation[relationA.name] + ");" << std::endl;
													joinname = true;
													out << "hashJoin" + std::to_string(joinNumber) + ".joinname = hashJoin" + std::to_string(joinNumber) + ";" << std::endl;
												}
												out << "hashJoin" + std::to_string(joinNumber) + "->condition.push_back(std::make_pair(\""+join.first+"\", " + "\""+join.second + "\"));" << std::endl;							
												operation[relationA.name] = "hashJoin" + std::to_string(joinNumber);
											}
										}	
									}else if(attribute.name == join.second){
										rightjoinname = true;
										for(Schema::Relation::Attribute attributeA : relationA.attributes){	
											if(attributeA.name == join.first){
												leftjoinname = true;
												if(!joinname){
													out << "HashJoin* hashJoin"+std::to_string(joinNumber) + " = new HashJoin("+ operation[relation.name] +", " + operation[relationA.name] + ");" << std::endl;
													joinname = true;
													out << "hashJoin" + std::to_string(joinNumber) + ".joinname = hashJoin" + std::to_string(joinNumber)+";" << std::endl;
												}
												out << "hashJoin" + std::to_string(joinNumber) + "->condition.push_back(std::make_pair(\""+join.second+"\", " + "\""+join.first + "\"));" << std::endl;							
												operation[relationA.name] = "hashJoin" + std::to_string(joinNumber);
			
											}
										}	
									}
								}
							}
							joinNumber++;
						}
					}
				}
			}
		}
	}
	if(query.relations.size() == 0)
		return;

	out << "Print *print = new Print(" + operation[query.relations[query.relations.size()-1]]+");" <<std::endl;
	for(std::string printname : query.selectnames)
		out << "print->cnames.push_back(\"" + printname + "\");" << std::endl;
	out << "print->produce();" << std::endl;
	out << "}" << std::endl;
	out.close();
}
